[{"title":"koa源码分析","date":"2017-05-25T07:29:49.000Z","path":"2017/05/25/koa源码分析/","text":"创建一个koa的后端服务只需要3步: 创建koa的app对象 为app添加中间件 监听端口，创建server 下面是一个简单的示例：123456789101112131415161718192021222324252627282930313233const Koa = require(&apos;koa&apos;);const app = new Koa();// x-response-timeapp.use(async function (ctx, next) &#123; console.log(&apos;x-response-time start&apos;) const start = new Date(); await next(); const ms = new Date() - start; ctx.set(&apos;X-Response-Time&apos;, `$&#123;ms&#125;ms`); console.log(&apos;x-response-time end&apos;)&#125;);// loggerapp.use(async function (ctx, next) &#123; console.log(&apos;logger start&apos;) const start = new Date(); await next(); const ms = new Date() - start; console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;ms&#125;`); console.log(&apos;logger end&apos;)&#125;);// responseapp.use(ctx =&gt; &#123; console.log(&apos;hello world&apos;) ctx.body = &apos;Hello World&apos;;&#125;);app.listen(3000); 当请求http://localhost:3000/时，页面返回&#39;Hello World’ 命令行里面顺序打印日志：’x-response-time start’ –&gt; ‘logger start’ –&gt; ‘hello world’ –&gt; ‘logger end’ –&gt; ‘x-response-time end’从请求到响应类似下图 创建Koa的app对象，Application继承Emitter对象， 1234567891011121314151617class Application extends Emitter &#123; constructor() &#123; super(); this.proxy = false; // 用于存储中间件的数组 this.middleware = []; this.subdomainOffset = 2; this.env = process.env.NODE_ENV || &apos;development&apos;; // 上下文对象 this.context = Object.create(context); // 请求对象 this.request = Object.create(request); // 响应对象 this.response = Object.create(response); &#125;&#125; 使用app.use()添加中间件1234567891011121314use(fn) &#123; //判断fn不是函数返回错误 if (typeof fn !== &apos;function&apos;) throw new TypeError(&apos;middleware must be a function!&apos;); if (isGeneratorFunction(fn)) &#123; deprecate(&apos;Support for generators will be removed in v3. &apos; + &apos;See the documentation for examples of how to convert old middleware &apos; + &apos;https://github.com/koajs/koa/blob/master/docs/migration.md&apos;); fn = convert(fn); &#125; debug(&apos;use %s&apos;, fn._name || fn.name || &apos;-&apos;); //把中间件函数push进application的middleware数组内 this.middleware.push(fn); return this;&#125; app.listen()监听端口，listen是createServer()的封装12345listen() &#123; debug(&apos;listen&apos;); const server = http.createServer(this.callback()); return server.listen.apply(server, arguments);&#125; 当服务接收到http请求时，触发callback函数，12345678910111213141516callback() &#123; const fn = compose(this.middleware); if (!this.listeners(&apos;error&apos;).length) this.on(&apos;error&apos;, this.onerror); const handleRequest = (req, res) =&gt; &#123; res.statusCode = 404; const ctx = this.createContext(req, res); const onerror = err =&gt; ctx.onerror(err); const handleResponse = () =&gt; respond(ctx); onFinished(res, onerror); return fn(ctx).then(handleResponse).catch(onerror); &#125;; return handleRequest;&#125; compose用于执行中间件函数，在callback()函数执行fn(ctx)，相当于从dispatch(0)开始，递归执行dispatch(i),直到执行完所有中间件函数12345678910111213141516171819202122232425262728function compose (middleware) &#123; // 参数判断 if (!Array.isArray(middleware)) throw new TypeError(&apos;Middleware stack must be an array!&apos;) for (const fn of middleware) &#123; if (typeof fn !== &apos;function&apos;) throw new TypeError(&apos;Middleware must be composed of functions!&apos;) &#125; return function (context, next) &#123; // last called middleware # let index = -1 return dispatch(0) function dispatch (i) &#123; if (i &lt;= index) return Promise.reject(new Error(&apos;next() called multiple times&apos;)) index = i let fn = middleware[i] if (i === middleware.length) fn = next if (!fn) return Promise.resolve() try &#123; // 执行中间件函数 return Promise.resolve(fn(context, function next () &#123; return dispatch(i + 1) &#125;)) &#125; catch (err) &#123; return Promise.reject(err) &#125; &#125; &#125;&#125; context用于管理请求，响应123456789101112131415161718192021createContext(req, res) &#123; const context = Object.create(this.context); const request = context.request = Object.create(this.request); const response = context.response = Object.create(this.response); // 通过context可以获取app,request,response对象 context.app = request.app = response.app = this; context.req = request.req = response.req = req; context.res = request.res = response.res = res; request.ctx = response.ctx = context; request.response = response; response.request = request; context.originalUrl = request.originalUrl = req.url; context.cookies = new Cookies(req, res, &#123; keys: this.keys, secure: request.secure &#125;); request.ip = request.ips[0] || req.socket.remoteAddress || &apos;&apos;; context.accept = request.accept = accepts(req); context.state = &#123;&#125;; return context;&#125;","tags":[{"name":"koa","slug":"koa","permalink":"https://facejiong.github.io/tags/koa/"}]},{"title":"Hello World","date":"2017-05-25T01:02:03.356Z","path":"2017/05/25/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]