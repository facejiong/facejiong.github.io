[{"title":"koa-router源码分析","date":"2017-05-31T05:55:38.000Z","path":"2017/05/31/koa-router源码分析/","text":"本文koa-router版本是7.2.0 路由是什么？根据请求url路径，通过判断或正则匹配返回对应的页面。下面是一个简单的原生路由例子：12345678910111213141516171819202122232425262728293031const Koa = require(&apos;koa&apos;)const app = new Koa()const Router = require(&apos;koa-router&apos;)var router = new Router()router.get(&apos;/&apos;, function (ctx, next) &#123; console.log(ctx.router) console.log(ctx.params) let html = ` &lt;p&gt;/&lt;/p&gt; ` ctx.body = html&#125;)router.get(&apos;/name/:id&apos;, function (ctx, next) &#123; let html = ` &lt;p&gt;name:$&#123;ctx.params.id&#125;&lt;/p&gt; ` ctx.body = html&#125;)router.get(&apos;/company&apos;, function (ctx, next) &#123; let html = ` &lt;p&gt;company&lt;/p&gt; ` ctx.body = html&#125;)app.use(router.routes()).use(router.allowedMethods())console.log(router)app.listen(3000) Router的结构，Router构造函数12345678910111213141516171819202122module.exports = Router;function Router(opts) &#123; if (!(this instanceof Router)) &#123; return new Router(opts); &#125; this.opts = opts || &#123;&#125;; this.methods = this.opts.methods || [ &apos;HEAD&apos;, &apos;OPTIONS&apos;, &apos;GET&apos;, &apos;PUT&apos;, &apos;PATCH&apos;, &apos;POST&apos;, &apos;DELETE&apos; ]; this.params = &#123;&#125;; //stack存储不同的Layer，Router和Layer的关系是Router包含Layer this.stack = [];&#125;; Layer构造函数123456789101112131415161718192021222324252627282930function Layer(path, methods, middleware, opts) &#123; this.opts = opts || &#123;&#125;; this.name = this.opts.name || null; this.methods = []; this.paramNames = []; this.stack = Array.isArray(middleware) ? middleware : [middleware]; methods.forEach(function(method) &#123; var l = this.methods.push(method.toUpperCase()); if (this.methods[l-1] === &apos;GET&apos;) &#123; this.methods.unshift(&apos;HEAD&apos;); &#125; &#125;, this); // ensure middleware is a function this.stack.forEach(function(fn) &#123; var type = (typeof fn); if (type !== &apos;function&apos;) &#123; throw new Error( methods.toString() + &quot; `&quot; + (this.opts.name || path) +&quot;`: `middleware` &quot; + &quot;must be a function, not `&quot; + type + &quot;`&quot; ); &#125; &#125;, this); this.path = path; this.regexp = pathToRegExp(path, this.paramNames, this.opts); debug(&apos;defined route %s %s&apos;, this.methods, this.opts.prefix + this.path);&#125;; 上述例子Router对象1234567891011121314151617181920212223242526272829Router &#123; opts: &#123;&#125;, methods: [ &apos;HEAD&apos;, &apos;OPTIONS&apos;, &apos;GET&apos;, &apos;PUT&apos;, &apos;PATCH&apos;, &apos;POST&apos;, &apos;DELETE&apos; ], params: &#123;&#125;, stack: [ Layer &#123; opts: [Object], name: null, methods: [Object], paramNames: [], stack: [Object], path: &apos;/&apos;, regexp: /^(?:\\/(?=$))?$/i &#125;, Layer &#123; opts: [Object], name: null, methods: [Object], paramNames: [Object], stack: [Object], path: &apos;/name/:id&apos;, regexp: /^\\/name\\/((?:[^\\/]+?))(?:\\/(?=$))?$/i &#125;, Layer &#123; opts: [Object], name: null, methods: [Object], paramNames: [], stack: [Object], path: &apos;/company&apos;, regexp: /^\\/company(?:\\/(?=$))?$/i &#125; ] &#125; path的匹配分两层，Router遍历所有layer，返回匹配的matched对象1234567891011121314151617181920212223242526272829Router.prototype.match = function (path, method) &#123; var layers = this.stack; var layer; var matched = &#123; //存储path匹配的layer path: [], //存储methods匹配的layer pathAndMethod: [], // 是否匹配成功 route: false &#125;; for (var len = layers.length, i = 0; i &lt; len; i++) &#123; layer = layers[i]; debug(&apos;test %s %s&apos;, layer.path, layer.regexp); if (layer.match(path)) &#123; matched.path.push(layer); if (layer.methods.length === 0 || ~layer.methods.indexOf(method)) &#123; matched.pathAndMethod.push(layer); if (layer.methods.length) matched.route = true; &#125; &#125; &#125; return matched;&#125;; Layer层通过正则匹配路径123Layer.prototype.match = function (path) &#123; return this.regexp.test(path);&#125;; Router通过use()将methods方法与Router联系起来app.use(router.routes()).use(router.allowedMethods());router.routes()返回一个中间件，用于对请求发起路由匹配，把一些router参数加入ctx对象,执行router.routes()，返回的是一个dispatch(ctx, next)方法1234567891011121314151617181920212223242526272829303132333435363738394041424344Router.prototype.routes = Router.prototype.middleware = function () &#123; var router = this; var dispatch = function dispatch(ctx, next) &#123; debug(&apos;%s %s&apos;, ctx.method, ctx.path); // 获取path var path = router.opts.routerPath || ctx.routerPath || ctx.path; // 发起path match，获取matched对象 var matched = router.match(path, ctx.method); var layerChain, layer, i; if (ctx.matched) &#123; ctx.matched.push.apply(ctx.matched, matched.path); &#125; else &#123; ctx.matched = matched.path; &#125; // 可以从ctx 取router ctx.router = router; // 判断是否匹配成功 if (!matched.route) return next(); var matchedLayers = matched.pathAndMethod var mostSpecificLayer = matchedLayers[matchedLayers.length - 1] ctx._matchedRoute = mostSpecificLayer.path; if (mostSpecificLayer.name) &#123; ctx._matchedRouteName = mostSpecificLayer.name; &#125; layerChain = matchedLayers.reduce(function(memo, layer) &#123; memo.push(function(ctx, next) &#123; ctx.captures = layer.captures(path, ctx.captures); ctx.params = layer.params(path, ctx.captures, ctx.params); return next(); &#125;); return memo.concat(layer.stack); &#125;, []); return compose(layerChain)(ctx, next); &#125;; dispatch.router = this; return dispatch;&#125;; router.allowedMethods()，执行router.allowedMethods()，返回allowedMethods(ctx, next)方法，判断请求的method是否被允许1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Router.prototype.allowedMethods = function (options) &#123; options = options || &#123;&#125;; var implemented = this.methods; return function allowedMethods(ctx, next) &#123; return next().then(function() &#123; var allowed = &#123;&#125;; if (!ctx.status || ctx.status === 404) &#123; ctx.matched.forEach(function (route) &#123; route.methods.forEach(function (method) &#123; allowed[method] = method; &#125;); &#125;); var allowedArr = Object.keys(allowed); // 判断请求method是否在允许范围内 if (!~implemented.indexOf(ctx.method)) &#123; if (options.throw) &#123; var notImplementedThrowable; if (typeof options.notImplemented === &apos;function&apos;) &#123; notImplementedThrowable = options.notImplemented(); // set whatever the user returns from their function &#125; else &#123; notImplementedThrowable = new HttpError.NotImplemented(); &#125; throw notImplementedThrowable; &#125; else &#123; ctx.status = 501; ctx.set(&apos;Allow&apos;, allowedArr); &#125; &#125; else if (allowedArr.length) &#123; if (ctx.method === &apos;OPTIONS&apos;) &#123; ctx.status = 204; ctx.set(&apos;Allow&apos;, allowedArr); &#125; else if (!allowed[ctx.method]) &#123; if (options.throw) &#123; var notAllowedThrowable; if (typeof options.methodNotAllowed === &apos;function&apos;) &#123; notAllowedThrowable = options.methodNotAllowed(); // set whatever the user returns from their function &#125; else &#123; notAllowedThrowable = new HttpError.MethodNotAllowed(); &#125; throw notAllowedThrowable; &#125; else &#123; ctx.status = 405; ctx.set(&apos;Allow&apos;, allowedArr); &#125; &#125; &#125; &#125; &#125;); &#125;;&#125;; app.use(router.routes()).use(router.allowedMethods());12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182Router.prototype.use = function () &#123; var router = this; // 将传入参数转换为数组 var middleware = Array.prototype.slice.call(arguments); var path = &apos;(.*)&apos;; // support array of paths if (Array.isArray(middleware[0]) &amp;&amp; typeof middleware[0][0] === &apos;string&apos;) &#123; middleware[0].forEach(function (p) &#123; router.use.apply(router, [p].concat(middleware.slice(1))); &#125;); return this; &#125; var hasPath = typeof middleware[0] === &apos;string&apos;; if (hasPath) &#123; path = middleware.shift(); &#125; middleware.forEach(function (m) &#123; if (m.router) &#123; // 对router.routes()参数的处理 m.router.stack.forEach(function (nestedLayer) &#123; if (path) nestedLayer.setPrefix(path); // 绑定layer if (router.opts.prefix) nestedLayer.setPrefix(router.opts.prefix); router.stack.push(nestedLayer); &#125;); if (router.params) &#123; Object.keys(router.params).forEach(function (key) &#123; m.router.param(key, router.params[key]); &#125;); &#125; &#125; else &#123; // 创建并注册一个route router.register(path, [], m, &#123; end: false, ignoreCaptures: !hasPath &#125;); &#125; &#125;); return this;&#125;;// 创建并注册一个routeRouter.prototype.register = function (path, methods, middleware, opts) &#123; opts = opts || &#123;&#125;; var router = this; var stack = this.stack; // support array of paths if (Array.isArray(path)) &#123; path.forEach(function (p) &#123; router.register.call(router, p, methods, middleware, opts); &#125;); return this; &#125; // create route Layer var route = new Layer(path, methods, middleware, &#123; end: opts.end === false ? opts.end : true, name: opts.name, sensitive: opts.sensitive || this.opts.sensitive || false, strict: opts.strict || this.opts.strict || false, prefix: opts.prefix || this.opts.prefix || &quot;&quot;, ignoreCaptures: opts.ignoreCaptures &#125;); if (this.opts.prefix) &#123; route.setPrefix(this.opts.prefix); &#125; // add parameter middleware Object.keys(this.params).forEach(function (param) &#123; route.param(param, this.params[param]); &#125;, this); stack.push(route); return route;&#125;;","tags":[{"name":"koa-router","slug":"koa-router","permalink":"https://facejiong.github.io/tags/koa-router/"}]},{"title":"koa源码分析","date":"2017-05-25T07:29:49.000Z","path":"2017/05/25/koa源码分析/","text":"本文koa版本是2.2.0创建一个koa的后端服务只需要3步: 创建koa的app对象 为app添加中间件 监听端口，创建server 下面是一个简单的示例：123456789101112131415161718192021222324252627282930313233const Koa = require(&apos;koa&apos;);const app = new Koa();// x-response-timeapp.use(async function (ctx, next) &#123; console.log(&apos;x-response-time start&apos;) const start = new Date(); await next(); const ms = new Date() - start; ctx.set(&apos;X-Response-Time&apos;, `$&#123;ms&#125;ms`); console.log(&apos;x-response-time end&apos;)&#125;);// loggerapp.use(async function (ctx, next) &#123; console.log(&apos;logger start&apos;) const start = new Date(); await next(); const ms = new Date() - start; console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;ms&#125;`); console.log(&apos;logger end&apos;)&#125;);// responseapp.use(ctx =&gt; &#123; console.log(&apos;hello world&apos;) ctx.body = &apos;Hello World&apos;;&#125;);app.listen(3000); 当请求http://localhost:3000/时，页面返回&#39;Hello World’ 命令行里面顺序打印日志：’x-response-time start’ –&gt; ‘logger start’ –&gt; ‘hello world’ –&gt; ‘logger end’ –&gt; ‘x-response-time end’从请求到响应类似下图 创建Koa的app对象，Application继承Emitter对象，代码结构如下1234567891011121314151617class Application extends Emitter &#123; constructor() &#123; super(); this.proxy = false; // 用于存储中间件的数组 this.middleware = []; this.subdomainOffset = 2; this.env = process.env.NODE_ENV || &apos;development&apos;; // 上下文对象 this.context = Object.create(context); // 请求对象 this.request = Object.create(request); // 响应对象 this.response = Object.create(response); &#125;&#125; koa的中间件是很重要，使用app.use()添加中间件1234567891011121314use(fn) &#123; //判断fn不是函数返回错误 if (typeof fn !== &apos;function&apos;) throw new TypeError(&apos;middleware must be a function!&apos;); if (isGeneratorFunction(fn)) &#123; deprecate(&apos;Support for generators will be removed in v3. &apos; + &apos;See the documentation for examples of how to convert old middleware &apos; + &apos;https://github.com/koajs/koa/blob/master/docs/migration.md&apos;); fn = convert(fn); &#125; debug(&apos;use %s&apos;, fn._name || fn.name || &apos;-&apos;); //把中间件函数push进application的middleware数组内 this.middleware.push(fn); return this;&#125; app.listen()监听端口，listen是createServer()的封装12345listen() &#123; debug(&apos;listen&apos;); const server = http.createServer(this.callback()); return server.listen.apply(server, arguments);&#125; 当服务接收到http请求时，触发callback函数，1234567891011121314151617callback() &#123; // 执行中间件 const fn = compose(this.middleware); if (!this.listeners(&apos;error&apos;).length) this.on(&apos;error&apos;, this.onerror); const handleRequest = (req, res) =&gt; &#123; res.statusCode = 404; const ctx = this.createContext(req, res); const onerror = err =&gt; ctx.onerror(err); const handleResponse = () =&gt; respond(ctx); onFinished(res, onerror); return fn(ctx).then(handleResponse).catch(onerror); &#125;; return handleRequest;&#125; compose用于执行中间件函数，在callback()函数执行fn(ctx)，相当于从dispatch(0)开始，递归执行dispatch(i),直到执行完所有中间件函数12345678910111213141516171819202122232425262728293031function compose (middleware) &#123; // 参数判断 if (!Array.isArray(middleware)) throw new TypeError(&apos;Middleware stack must be an array!&apos;) for (const fn of middleware) &#123; if (typeof fn !== &apos;function&apos;) throw new TypeError(&apos;Middleware must be composed of functions!&apos;) &#125; return function (context, next) &#123; // last called middleware # // 闭包，存储index变量，中间件执行当前坐标 let index = -1 // 从第一个中间件开始执行 return dispatch(0) function dispatch (i) &#123; if (i &lt;= index) return Promise.reject(new Error(&apos;next() called multiple times&apos;)) index = i let fn = middleware[i] if (i === middleware.length) fn = next if (!fn) return Promise.resolve() try &#123; // 执行中间件函数 return Promise.resolve(fn(context, function next () &#123; // 执行下一个中间件 return dispatch(i + 1) &#125;)) &#125; catch (err) &#123; return Promise.reject(err) &#125; &#125; &#125;&#125; context上下文用于管理请求，响应123456789101112131415161718192021createContext(req, res) &#123; const context = Object.create(this.context); const request = context.request = Object.create(this.request); const response = context.response = Object.create(this.response); // 通过context可以获取app,request,response对象 context.app = request.app = response.app = this; context.req = request.req = response.req = req; context.res = request.res = response.res = res; request.ctx = response.ctx = context; request.response = response; response.request = request; context.originalUrl = request.originalUrl = req.url; context.cookies = new Cookies(req, res, &#123; keys: this.keys, secure: request.secure &#125;); request.ip = request.ips[0] || req.socket.remoteAddress || &apos;&apos;; context.accept = request.accept = accepts(req); context.state = &#123;&#125;; return context;&#125;","tags":[{"name":"koa","slug":"koa","permalink":"https://facejiong.github.io/tags/koa/"}]},{"title":"Hello World","date":"2017-05-25T01:02:03.356Z","path":"2017/05/25/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]