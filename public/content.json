[{"title":"使用TensorFlow的softmax回归识别手写数字图片","date":"2017-06-15T05:19:47.000Z","path":"2017/06/15/使用TensorFlow的softmax回归识别手写数字图片/","text":"MNIST数据集数据集中每个数据单元由一张图片和一个对应标签组成。图片包含28*28个像素点每个像素点的值介于0-1之间， Softmax回归Softmax回归是Logistic回归的推广，Logistic回归用于处理二分类问题，Softmax回归可以处理多分类问题。Logistic函数(或称为Sigmoid函数)g(z)=11+e−z g(z) = \\frac{1}{1 + e^{-z}} g(z)=​1+e​−z​​​​1​​线性函数θ0+θ1x1+...+θnxn=∑i=0nθixi=θTx \\theta _{0} + \\theta _{1}x_{1} + ... + \\theta _{n}x_{n} = \\sum_{i=0}^{n} \\theta _{i}x_{i} = \\theta ^{T}x θ​0​​+θ​1​​x​1​​+...+θ​n​​x​n​​=∑​i=0​n​​θ​i​​x​i​​=θ​T​​x代入g(z)hθ(x)=g(θTx)=11+e−θTx h _{\\theta}(x) = g(\\theta ^{T}x) = \\frac{1}{1 + e ^{-\\theta ^{T}x}} h​θ​​(x)=g(θ​T​​x)=​1+e​−θ​T​​x​​​​1​​可推导P(y=1∣x;θ)=hθ(x) P(y=1|x;\\theta) = h _{\\theta}(x) P(y=1∣x;θ)=h​θ​​(x)P(y=0∣x;θ)=1−hθ(x) P(y=0|x;\\theta) = 1 - h _{\\theta}(x) P(y=0∣x;θ)=1−h​θ​​(x) 使用最大似然估计进行参数估计，假设所有样本独立同分布，P(y∣x;θ)=(hθ(x))y(1−hθ(x))1−y P(y|x;\\theta) = (h _{\\theta}(x)) ^{y} (1 - h _{\\theta}(x)) ^ {1-y} P(y∣x;θ)=(h​θ​​(x))​y​​(1−h​θ​​(x))​1−y​​似然函数L(θ)=∏i=1mP(y(i)∣x(i);θ)=∏i=1m(hθ(x(i)))y(i)(1−hθ(x(i)))1−y(i) L(\\theta) = \\prod_{i=1}^{m}P(y ^{(i)} | x^{(i)}; \\theta) = \\prod_{i=1}^{m} (h _{\\theta}(x ^{(i)})) ^{y ^{(i)}} (1 - h_{\\theta}(x ^{(i)})) ^{1 - y ^{(i)}} L(θ)=∏​i=1​m​​P(y​(i)​​∣x​(i)​​;θ)=∏​i=1​m​​(h​θ​​(x​(i)​​))​y​(i)​​​​(1−h​θ​​(x​(i)​​))​1−y​(i)​​​​对数似然函数l(θ)=logL(θ)=∑i=1m((y(i))log(hθ(x(i)))+(1−y(i))log(1−hθ(x(i)))) l(\\theta) = log L(\\theta) = \\sum_{i=1}^{m} ( (y^{(i)})log(h_{\\theta}(x^{(i)})) + (1-y^{(i)})log(1-h_{\\theta}(x^{(i)}))) l(θ)=logL(θ)=∑​i=1​m​​((y​(i)​​)log(h​θ​​(x​(i)​​))+(1−y​(i)​​)log(1−h​θ​​(x​(i)​​)))最大似然估计是求l(θ)l(\\theta)l(θ)取最大值时的θ。可以使用梯度下降法求。 图片分类需要识别0-9，使用Softmax回归取得每个数字的概率。 p(y=0∣x)=11+e(wTx+b) p(y=0|x) = \\frac{1}{1 + e^{(w^{T}x+b)}} p(y=0∣x)=​1+e​(w​T​​x+b)​​​​1​​","tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://facejiong.github.io/tags/TensorFlow/"}]},{"title":"神经网络基础","date":"2017-06-14T07:16:38.000Z","path":"2017/06/14/神经网络基础/","text":"DNN，Deep Neural Networks，深度神经网络对于人工智能的实现分为两派：一派是自顶向下通过逻辑和符号推导实现，另一类是自底向上通过模拟大脑中的神经网络实现。神经网络是第二派的实现。神经网络由若干神经元组成 神经元输入：x1,x2,…xn权重：w1,w2,…wn组合函数：c激活函数：a偏移：b输出：y 感知机神经元最早的起源于上世纪50-60年代，Frank Rosenblatt发明了一种叫感知机的神经元。感知机的输入输出是二进制0或1。 sigmoid神经元在使用感知机构建神经网络时，神经元权重和偏移发生很小变化都可能导致输出的剧烈变化。所以引入了sigmoid神经元。sigmoid神经元的输入输出是浮点值。感知机sigmoid神经元sigmoid神经元相当于平滑的感知机，意味着当权重和偏移变化时，输出按预期小幅度变化。 神经网络的结构输入层–&gt;隐层–&gt;输出层隐层的设计需要考虑层数和时间的平衡。","tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://facejiong.github.io/tags/TensorFlow/"}]},{"title":"使用tf.contrib.learn快速搭建DNN识别鸢尾花","date":"2017-06-13T13:17:08.000Z","path":"2017/06/13/使用tf.contrib.learn快速搭建DNN识别鸢尾花/","text":"tf.contrib.learn是TensorFlow提供高级API。下面是使用DNN预测鸢尾花卉数据集的例子。先分析下鸢尾花卉数据集,0/1/2分别代表Setosa,versicolor,virginica三个种类的花 Sepal.Length（花萼长度） Sepal.Width（花萼宽度） Petal.Length（花瓣长度） Petal.Width（花瓣宽度） 种类 7.9 3.8 6.4 2.0 0/1/2 １、载入数据２、构造神经网络分类器３、利用训练数据拟合模型４、评估模型的精确性５、新的样本分类 123456789101112131415161718192021222324252627282930313233343536373839404142434445from __future__ import absolute_importfrom __future__ import divisionfrom __future__ import print_functionimport tensorflow as tfimport numpy as npIRIS_TRAINING = &quot;iris_training.csv&quot;IRIS_TEST = &quot;iris_test.csv&quot;# 加载数据集training_set = tf.contrib.learn.datasets.base.load_csv_with_header( filename=IRIS_TRAINING, target_dtype=np.int, features_dtype=np.float32)test_set = tf.contrib.learn.datasets.base.load_csv_with_header( filename=IRIS_TEST, target_dtype=np.int, features_dtype=np.float32)print(training_set)# 特征feature_columns = [tf.contrib.layers.real_valued_column(&quot;&quot;, dimension=4)]# 构造３层DNN网络，每层分别是10,20,10个节点classifier = tf.contrib.learn.DNNClassifier(feature_columns=feature_columns, hidden_units=[10, 20, 10], n_classes=3, model_dir=&quot;/tmp/iris_model&quot;)# 拟合模型，迭代2000步classifier.fit(x=training_set.data, y=training_set.target, steps=2000)# 计算精度accuracy_score = classifier.evaluate(x=test_set.data, y=test_set.target)[&quot;accuracy&quot;]print(&apos;Accuracy: &#123;0:f&#125;&apos;.format(accuracy_score))# 对２个新样本预测new_samples = np.array( [[6.4, 3.2, 4.5, 1.5], [5.8, 3.1, 5.0, 1.7]], dtype=float)y = list(classifier.predict(new_samples, as_iterable=True))print(&apos;Predictions: &#123;&#125;&apos;.format(str(y))) 输出12Accuracy: 0.966667Predictions: [1, 1]","tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://facejiong.github.io/tags/TensorFlow/"}]},{"title":"TensorFlow基础使用","date":"2017-06-11T10:18:59.000Z","path":"2017/06/11/TensorFlow基础使用/","text":"基础使用TensorFlow几个要点１、使用图graph来代表计算２、在Sessions环境中执行图３、使用tensors代表数据４、使用Variables变量维护状态５、使用feeds和fetches获取或写入操作 图的使用构建下图 构建图123456import tensorflow as tf# 声明常量matrix1 = tf.constant([[3., 3.]])matrix2 = tf.constant([[2.],[2.]])# 声明操作product = tf.matmul(matrix1, matrix2) 启动图12345678# 启动默认图sess = tf.Session()# 在图中执行 操作result = sess.run(product)print(result)# ==&gt; [[ 12.]]# 关闭图sess.close() Sessions自动释放资源123with tf.Session() as sess: result = sess.run([product]) print(result) 在Python解释器中使用在解释器中可以使用InteractiveSession class, Tensor.eval() ，Operation.run()，避免使用变量保存session1234567891011121314151617# Enter an interactive TensorFlow Session.import tensorflow as tfsess = tf.InteractiveSession()x = tf.Variable([1.0, 2.0])a = tf.constant([3.0, 3.0])# Initialize &apos;x&apos; using the run() method of its initializer op.x.initializer.run()# Add an op to subtract &apos;a&apos; from &apos;x&apos;. Run it and print the resultsub = tf.sub(x, a)print(sub.eval())# ==&gt; [-2. -1.]# Close the Session when we&apos;re done.sess.close() TensorsTensorFlow使用tensor数据结构表示所有数据，在不同操作之间只能传入tensor数据。tensor类似Ｎ维数组，一个tensor包括一个数据类型，一个rank(阶，张量的维数)和一个shape（形状，张量的维度） 阶 形状 维数 实例 0 [] 0-D 纯量 s = 483 1 [D0] 1-D 向量 v = [1.1, 2.2, 3.3] 2 [D0,D1] 2-D 矩阵 m = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] 3 [D0,D1,D2] 3-D 3阶张量 t = [[[2], [4], [6]], [[8], [10], [12]], [[14], [16], [18]]] n [D0,…Dn] 4-D n阶 变量变量存储图的状态12345678910111213141516171819202122232425262728import tensorflow as tf# 创建变量state,并初始化为０state = tf.Variable(0, name=&quot;counter&quot;)# 创建常量one,值为１one = tf.constant(1)# 加操作new_value = tf.add(state, one)# 赋值 new_value给stateupdate = tf.assign(state, new_value)# 初始化所有变量init_op = tf.global_variables_initializer()# 启动图，执行操作with tf.Session() as sess: # 执行init_op操作 sess.run(init_op) # 打印state初始值 print(sess.run(state)) # 执行更新state的操作，并打印 for _ in range(3): sess.run(update) print(sess.run(state))# output:# 0# 1# 2# 3 sess.run(init_op)之前并没有执行任何操作，所以state为０。sess.run(update)执行操作才会更新state值。 Fetches用于取出操作的结果。尽量在一次操作运行中取出多个tensor，提高效率。12345678910111213141516import tensorflow as tfinput1 = tf.constant([3.0])input2 = tf.constant([2.0])input3 = tf.constant([5.0])# 加intermed = tf.add(input2, input3)# 乘mul = tf.multiply(input1, intermed)# (input2 + input3) * input1with tf.Session() as sess: result = sess.run([mul, intermed]) print(result)# output:# [array([ 21.], dtype=float32), array([ 7.], dtype=float32)] Feeds用于临时保存tensor值，调用方法结束后，feed消失123456789101112import tensorflow as tfinput1 = tf.placeholder(tf.float32)input2 = tf.placeholder(tf.float32)# 乘output = tf.multiply(input1, input2)with tf.Session() as sess: print(sess.run([output], feed_dict=&#123;input1:[7.], input2:[2.]&#125;))# 输出:# [array([ 14.], dtype=float32)]","tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://facejiong.github.io/tags/TensorFlow/"}]},{"title":"TensorFlow入门","date":"2017-06-10T15:01:39.000Z","path":"2017/06/10/TensorFlow入门/","text":"一个使用梯度下降实现线性回归的例子123456789101112131415161718192021222324252627282930313233343536373839import tensorflow as tfimport numpy as np# 使用NumPy生成100个随机数, y = x * 0.1 + 0.3x_data = np.random.rand(100).astype(np.float32)y_data = x_data * 0.1 + 0.3# 目的是求出方程y_data = W * x_data + b的W和b的值# 声明变量W和bW = tf.Variable(tf.random_uniform([1], -1.0, 1.0))b = tf.Variable(tf.zeros([1]))y = W * x_data + b# 求最小均方差# reduce_mean 求平均值# square 求平方# 梯度下降优化loss = tf.reduce_mean(tf.square(y - y_data))optimizer = tf.train.GradientDescentOptimizer(0.5)# 使用梯度下降算法求loss最小值train = optimizer.minimize(loss)# 对所有变量进行初始化init = tf.global_variables_initializer()# 启动graph，执行阶段sess = tf.Session()sess.run(init)# 拟合直线for step in range(501): sess.run(train) if step % 20 == 0: print(step, sess.run(W), sess.run(b))# 最佳结果是W: [0.1], b: [0.3]# 结束后关闭Sessionsess.close() 终端输出：12345678910110 [ 0.86394864] [-0.13441049]20 [ 0.34454051] [ 0.1738376]40 [ 0.17663138] [ 0.26046464]60 [ 0.12401388] [ 0.28761086]80 [ 0.10752521] [ 0.29611763]100 [ 0.10235816] [ 0.29878339]120 [ 0.10073899] [ 0.29961875]140 [ 0.10023157] [ 0.29988053]160 [ 0.10007257] [ 0.29996258]180 [ 0.10002275] [ 0.29998827]200 [ 0.10000715] [ 0.29999632] TensorFlow的几个概念Session：用于执行graph的上下文环境Graph：计算任务，由许多节点组成节点：代表不同的操作，被分配到cpu或gpu执行Variable：变量 TensorFlow分两个阶段，构建阶段和执行阶段 梯度下降先随机对W赋值，然后改变W的值，使loss按梯度下降的方向进行减少","tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"https://facejiong.github.io/tags/TensorFlow/"}]},{"title":"一步一步实现一个小的koa","date":"2017-06-08T05:47:35.000Z","path":"2017/06/08/一步一步实现一个小的koa/","text":"koa对象1 http服务创建2 中间件的添加3 为中间件传入请求，响应参数4 中间件的执行1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const Emitter = require(&apos;events&apos;);const http = require(&apos;http&apos;);module.exports = class Application extends Emitter &#123; constructor() &#123; super(); this.middleware = []; &#125; // 创建http服务，监听端口 listen() &#123; const server = http.createServer(this.callback()); return server.listen.apply(server, arguments); &#125; // 接收到http请求，触发的回调函数 callback() &#123; console.log(&apos;http callback&apos;) console.log(this) const fn = this.compose(this.middleware); const handleRequest = (request, response) =&gt; &#123; // 把http请求，响应放进context传入中间件 const context = Object.create(null, &#123; request: &#123;value: request&#125;, response: &#123;value: response&#125;, &#125;) return fn(context).catch((err) =&gt; &#123; console.log(&apos;err&apos;) console.log(err) &#125;); &#125;; return handleRequest; &#125; // 添加中间件 use(fn) &#123; this.middleware.push(fn); return this; &#125; // 执行所有中间件 compose(middleware) &#123; console.log(&apos;compose&apos;) console.log(middleware) return function(context, next) &#123; console.log(&apos;dispatch&apos;) let index = -1 return dispatch(0) function dispatch(i) &#123; console.log(&apos;dispatch:&apos; + i) index = i let fn = middleware[i] if (i === middleware.length) fn = next if (!fn) return Promise.resolve() try &#123; return Promise.resolve(fn(context, function next () &#123; return dispatch(i + 1) &#125;)) &#125; catch (err) &#123; return Promise.reject(err) &#125; &#125; &#125; &#125;&#125; 例子12345678910111213141516171819202122232425262728293031323334const Koa = require(&apos;./application&apos;)const app = new Koa()// x-response-timeapp.use(async function (context, next) &#123; console.log(&apos;x-response-time start&apos;) console.log(context) const start = new Date() await next() const ms = new Date() - start console.log(&apos;x-response-time end&apos;)&#125;)// loggerapp.use(async function (context, next) &#123; console.log(&apos;logger start&apos;) const start = new Date() await next() const ms = new Date() - start console.log(&apos;logger end&apos;)&#125;)// responseapp.use(context =&gt; &#123; // 可以使用原生的方法处理请求，响应 console.log(&apos;hello world&apos;) context.response.stateCode = &apos;200&apos; context.response.end(&apos;Hello World&apos;)&#125;)app.listen(3001) 最终输出logkoa-dispatch 中间件执行发起","tags":[{"name":"koa","slug":"koa","permalink":"https://facejiong.github.io/tags/koa/"}]},{"title":"机器学习-朴素贝叶斯","date":"2017-06-06T11:23:52.000Z","path":"2017/06/06/机器学习-朴素贝叶斯/","text":"贝叶斯贝叶斯推断：先估计一个值，根据实际结果不断修正。贝叶斯定理：P(A|B)，条件概率，事件B发生的情况下，事件A发生的概率。由文氏图得P(A∣B)=P(A⋂B)P(B) P \\left ( A|B \\right ) = \\frac {P \\left ( A \\bigcap B \\right )} {P \\left ( B \\right )} P(A∣B)=​P(B)​​P(A⋂B)​​又P(B∣A)=P(A⋂B)P(B) P \\left ( B|A \\right ) = \\frac {P \\left ( A \\bigcap B \\right )} {P \\left ( B \\right )} P(B∣A)=​P(B)​​P(A⋂B)​​故P(A⋂B)=P(A∣B)∗P(B)=P(B∣A)∗P(A) P \\left ( A \\bigcap B \\right ) = P \\left ( A|B \\right ) \\ast P \\left ( B \\right ) = P \\left ( B|A \\right ) \\ast P \\left ( A \\right ) P(A⋂B)=P(A∣B)∗P(B)=P(B∣A)∗P(A)最终P(A∣B)=P(B∣A)∗P(A)P(B) P \\left ( A|B \\right ) = \\frac{P \\left ( B|A \\right ) \\ast P \\left ( A \\right )}{P \\left ( B \\right )} P(A∣B)=​P(B)​​P(B∣A)∗P(A)​​ 全概率公式由文氏图得P(B)=P(B⋂A)+P(B⋂A′) P \\left ( B \\right ) = P \\left ( B \\bigcap A \\right ) + P \\left ( B \\bigcap{A}&#x27; \\right ) P(B)=P(B⋂A)+P(B⋂A​′​​)由条件概率公式得P(B⋂A)=P(B∣A)∗P(A) P \\left ( B \\bigcap A \\right ) = P \\left ( B|A \\right ) \\ast P \\left ( A \\right ) P(B⋂A)=P(B∣A)∗P(A)代入得全概率公式P(B)=P(B∣A)∗P(A)+P(B∣A′)∗P(A′) P \\left ( B \\right ) = P \\left ( B|A \\right ) \\ast P \\left ( A \\right ) + P \\left ( B|{A}&#x27; \\right ) \\ast P \\left ( {A}&#x27; \\right ) P(B)=P(B∣A)∗P(A)+P(B∣A​′​​)∗P(A​′​​)代入条件概率公式得到条件概率另一种写法 P(A∣B)=P(B∣A)∗P(A)P(B)=P(B∣A)∗P(A)P(B∣A)∗P(A)+P(B∣A′)∗P(A′) P \\left ( A|B \\right ) = \\frac{P \\left ( B|A \\right ) \\ast P \\left ( A \\right )}{P \\left ( B \\right )} = \\frac{P\\left ( B|A \\right )\\ast P\\left ( A \\right )}{P \\left ( B|A \\right ) \\ast P \\left ( A \\right ) + P \\left ( B|{A}&#x27; \\right ) \\ast P \\left ( {A}&#x27; \\right )} P(A∣B)=​P(B)​​P(B∣A)∗P(A)​​=​P(B∣A)∗P(A)+P(B∣A​′​​)∗P(A​′​​)​​P(B∣A)∗P(A)​​ 贝叶斯推断条件概率P(A∣B)=P(A)∗P(B∣A)P(B) P \\left ( A|B \\right ) = P \\left ( A \\right ) \\ast \\frac{P \\left ( B|A \\right )}{P \\left ( B \\right )} P(A∣B)=P(A)∗​P(B)​​P(B∣A)​​P(A)：先验概率，在事件B发生之前，事件A发生的概率，与事件B无关。P(A|B)：后验概率，在事件B发生之后，事件A发生的概率。P(B|A)/P(B)：可能性函数，用于调整先验概率，使之接近后验概率。若大于1，先验概率被增强，后验概率变大，反之，先验概率被削弱，后验概率变小。 使用贝叶斯过滤垃圾邮件假定先验概率，垃圾邮件的概率P(S)=50%，正常邮件的概率P(H)=50%根据条件概率公式，某个词语存在的条件下，垃圾邮件的概率：P(S∣W)=P(W∣S)∗P(S)P(W∣S)∗P(S)+P(W∣H)∗P(H) P \\left ( S|W \\right ) = \\frac{P\\left ( W|S \\right ) \\ast P\\left ( S \\right )}{P\\left ( W|S \\right )\\ast P\\left ( S \\right )+P\\left ( W|H \\right )\\ast P\\left ( H \\right )} P(S∣W)=​P(W∣S)∗P(S)+P(W∣H)∗P(H)​​P(W∣S)∗P(S)​​需要求出P(W|S)垃圾邮件中W单词的概率和P(W|H)正常邮件中W单词的概率一般情况下我们需要根据多个单词的出现判断垃圾邮件P1 = P(S|W1)P2 = P(S|W2) 事件 单词W1 单词W2 是否是垃圾邮件 垃圾邮件E1 P1 P2 P(S) 正常邮件E2 1-P1 1-P2 1-P(S) 假设事件独立P(E1) = P(S|W1)P(S|W2)P(S)P(E2) = (1-P(S|W1))(1-P(S|W2))(1-P(S))P=P(E1)P(E1)+P(E2)=P(S∣W1)P(S∣W2)P(S)P(S∣W1)P(S∣W2)P(S)+(1−P(S∣W1)(1−P(S∣W2)(1−P(S))))P=\\frac{P\\left ( E1 \\right )}{P\\left ( E1 \\right ) + P\\left ( E2 \\right )}=\\frac{P(S|W1)P(S|W2)P(S)}{P(S|W1)P(S|W2)P(S)+(1-P(S|W1)(1-P(S|W2)(1-P(S))))}P=​P(E1)+P(E2)​​P(E1)​​=​P(S∣W1)P(S∣W2)P(S)+(1−P(S∣W1)(1−P(S∣W2)(1−P(S))))​​P(S∣W1)P(S∣W2)P(S)​​代入P(S)=0.5P=P(S∣W1)P(S∣W2)P(S∣W1)P(S∣W2)+(1−P(S∣W1)(1−P(S∣W2)))P=\\frac{P(S|W1)P(S|W2)}{P(S|W1)P(S|W2)+(1-P(S|W1)(1-P(S|W2)))}P=​P(S∣W1)P(S∣W2)+(1−P(S∣W1)(1−P(S∣W2)))​​P(S∣W1)P(S∣W2)​​P=P1P2P1P2+(1−P1)(1−P2)P=\\frac{P1P2}{P1P2 + (1-P1)(1-P2)}P=​P1P2+(1−P1)(1−P2)​​P1P2​​扩展到所有单词P=P1P2...PnP1P2...Pn+(1−P1)(1−P2)...(1−Pn)P=\\frac{P1P2...Pn}{P1P2...Pn + (1-P1)(1-P2)...(1-Pn)}P=​P1P2...Pn+(1−P1)(1−P2)...(1−Pn)​​P1P2...Pn​​ 朴素贝叶斯三个模型（scikit-learn）高斯Gaussian:特征值分布符合高斯分布多项式Multinomial:适合文本分类伯努利Bernoulli:特征取值是布尔型的","tags":[{"name":"scikit-learn","slug":"scikit-learn","permalink":"https://facejiong.github.io/tags/scikit-learn/"}]},{"title":"人工智能应用收集","date":"2017-06-06T10:49:19.000Z","path":"2017/06/06/人工智能应用收集/","text":"名称 介绍 链接 logojoy 使用遗传算法生成logo https://www.logojoy.com/ PaintsChainer 漫画线稿自动上色 https://github.com/pfnet/PaintsChainer","tags":[{"name":"AI","slug":"AI","permalink":"https://facejiong.github.io/tags/AI/"}]},{"title":"koa-router源码分析","date":"2017-05-31T05:55:38.000Z","path":"2017/05/31/koa-router源码分析/","text":"本文koa-router版本是7.2.0 路由定义：根据请求url路径，通过判断或正则匹配返回对应的页面。 示例：原生示例：1234567891011121314151617181920212223242526272829303132const Koa = require(&apos;koa&apos;)const app = new Koa()async function route( url ) &#123; let view = `&lt;html&gt;&lt;header&gt;&lt;/header&gt;&lt;body&gt;404&lt;/body&gt;&lt;/html&gt;` switch ( url ) &#123; case &apos;/&apos;: view = `&lt;html&gt;&lt;header&gt;&lt;/header&gt;&lt;body&gt;index&lt;/body&gt;&lt;/html&gt;` break case &apos;/index&apos;: view = `&lt;html&gt;&lt;header&gt;&lt;/header&gt;&lt;body&gt;index&lt;/body&gt;&lt;/html&gt;` break case &apos;/todo&apos;: view = `&lt;html&gt;&lt;header&gt;&lt;/header&gt;&lt;body&gt;to do&lt;/body&gt;&lt;/html&gt;` break case &apos;/404&apos;: view = `&lt;html&gt;&lt;header&gt;&lt;/header&gt;&lt;body&gt;404&lt;/body&gt;&lt;/html&gt;` break default: break &#125; let html = view return html&#125;app.use( async ( ctx ) =&gt; &#123; let url = ctx.request.url let html = await route( url ) ctx.body = html&#125;)app.listen(3000) 一个简单的koa-router例子12345678910111213141516171819202122232425262728293031const Koa = require(&apos;koa&apos;)const app = new Koa()const Router = require(&apos;koa-router&apos;)var router = new Router()router.get(&apos;/&apos;, function (ctx, next) &#123; console.log(ctx.router) console.log(ctx.params) let html = ` &lt;p&gt;/&lt;/p&gt; ` ctx.body = html&#125;)router.get(&apos;/name/:id&apos;, function (ctx, next) &#123; let html = ` &lt;p&gt;name:$&#123;ctx.params.id&#125;&lt;/p&gt; ` ctx.body = html&#125;)router.get(&apos;/company&apos;, function (ctx, next) &#123; let html = ` &lt;p&gt;company&lt;/p&gt; ` ctx.body = html&#125;)app.use(router.routes()).use(router.allowedMethods())console.log(router)app.listen(3000) 多个子router的使用123456789101112131415161718192021222324252627282930313233const Koa = require(&apos;koa&apos;)const app = new Koa()const Router = require(&apos;koa-router&apos;)// 子路由1let home = new Router()home.get(&apos;/&apos;, async ( ctx )=&gt;&#123; let html = ` &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;/page/helloworld&quot;&gt;/page/helloworld&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/page/404&quot;&gt;/page/404&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; ` ctx.body = html&#125;)// 子路由2let page = new Router()page.get(&apos;/404&apos;, async ( ctx )=&gt;&#123; ctx.body = &apos;404 page!&apos;&#125;).get(&apos;/helloworld&apos;, async ( ctx )=&gt;&#123; ctx.body = &apos;helloworld page!&apos;&#125;)// 装载子路由let router = new Router()router.use(&apos;/&apos;, home.routes(), home.allowedMethods())router.use(&apos;/page&apos;, page.routes(), page.allowedMethods())// 加载路由中间件app.use(router.routes()).use(router.allowedMethods())app.listen(3000) 路由嵌套12345678910111213141516171819const Koa = require(&apos;koa&apos;)const app = new Koa()const Router = require(&apos;koa-router&apos;)let home = new Router()let page = new Router()page.get(&apos;/:pageid&apos;, async ( ctx )=&gt;&#123; let html = ` &lt;p&gt;page:$&#123;ctx.params.pageid&#125;&lt;/p&gt; ` ctx.body = html&#125;)// /home/232/pagehome.use(&apos;/home/:fid/page&apos;, page.routes(), page.allowedMethods());// 加载路由中间件app.use(home.routes())app.listen(3000) 路由前缀123456789101112131415161718192021222324const Koa = require(&apos;koa&apos;)const app = new Koa()const Router = require(&apos;koa-router&apos;)let router = new Router(&#123; prefix: &apos;/users&apos;&#125;)// /usersrouter.get(&apos;/:pageid&apos;, async ( ctx )=&gt;&#123; let html = ` &lt;p&gt;user home&lt;/p&gt; ` ctx.body = html&#125;)// /users/:useridrouter.get(&apos;/:userid&apos;, async ( ctx )=&gt;&#123; let html = ` &lt;p&gt;user-id:$&#123;ctx.params.userid&#125;&lt;/p&gt; ` ctx.body = html&#125;)app.use(router.routes()).use(router.allowedMethods())app.listen(3000) Router的结构Router构造函数12345678910111213141516171819202122module.exports = Router;function Router(opts) &#123; if (!(this instanceof Router)) &#123; return new Router(opts); &#125; this.opts = opts || &#123;&#125;; this.methods = this.opts.methods || [ &apos;HEAD&apos;, &apos;OPTIONS&apos;, &apos;GET&apos;, &apos;PUT&apos;, &apos;PATCH&apos;, &apos;POST&apos;, &apos;DELETE&apos; ]; this.params = &#123;&#125;; //stack存储不同的Layer，Router和Layer的关系是Router包含Layer this.stack = [];&#125;; Layer构造函数123456789101112131415161718192021222324252627282930function Layer(path, methods, middleware, opts) &#123; this.opts = opts || &#123;&#125;; this.name = this.opts.name || null; this.methods = []; this.paramNames = []; this.stack = Array.isArray(middleware) ? middleware : [middleware]; methods.forEach(function(method) &#123; var l = this.methods.push(method.toUpperCase()); if (this.methods[l-1] === &apos;GET&apos;) &#123; this.methods.unshift(&apos;HEAD&apos;); &#125; &#125;, this); // ensure middleware is a function this.stack.forEach(function(fn) &#123; var type = (typeof fn); if (type !== &apos;function&apos;) &#123; throw new Error( methods.toString() + &quot; `&quot; + (this.opts.name || path) +&quot;`: `middleware` &quot; + &quot;must be a function, not `&quot; + type + &quot;`&quot; ); &#125; &#125;, this); this.path = path; this.regexp = pathToRegExp(path, this.paramNames, this.opts); debug(&apos;defined route %s %s&apos;, this.methods, this.opts.prefix + this.path);&#125;; Router对象可以看出layer存储匹配规则等1234567891011121314151617181920212223242526272829Router &#123; opts: &#123;&#125;, methods: [ &apos;HEAD&apos;, &apos;OPTIONS&apos;, &apos;GET&apos;, &apos;PUT&apos;, &apos;PATCH&apos;, &apos;POST&apos;, &apos;DELETE&apos; ], params: &#123;&#125;, stack: [ Layer &#123; opts: [Object], name: null, methods: [Object], paramNames: [], stack: [Object], path: &apos;/&apos;, regexp: /^(?:\\/(?=$))?$/i &#125;, Layer &#123; opts: [Object], name: null, methods: [Object], paramNames: [Object], stack: [Object], path: &apos;/name/:id&apos;, regexp: /^\\/name\\/((?:[^\\/]+?))(?:\\/(?=$))?$/i &#125;, Layer &#123; opts: [Object], name: null, methods: [Object], paramNames: [], stack: [Object], path: &apos;/company&apos;, regexp: /^\\/company(?:\\/(?=$))?$/i &#125; ] &#125; path的匹配分两层，Router遍历所有layer，返回匹配的matched对象1234567891011121314151617181920212223242526272829Router.prototype.match = function (path, method) &#123; var layers = this.stack; var layer; var matched = &#123; //存储path匹配的layer path: [], //存储methods匹配的layer pathAndMethod: [], // 是否匹配成功 route: false &#125;; for (var len = layers.length, i = 0; i &lt; len; i++) &#123; layer = layers[i]; debug(&apos;test %s %s&apos;, layer.path, layer.regexp); if (layer.match(path)) &#123; matched.path.push(layer); if (layer.methods.length === 0 || ~layer.methods.indexOf(method)) &#123; matched.pathAndMethod.push(layer); if (layer.methods.length) matched.route = true; &#125; &#125; &#125; return matched;&#125;; Layer层通过正则匹配路径123Layer.prototype.match = function (path) &#123; return this.regexp.test(path);&#125;; Router.use()Router通过use()将methods方法与Router联系起来app.use(router.routes()).use(router.allowedMethods());router.routes()返回一个中间件，用于对请求发起路由匹配，把一些router参数加入ctx对象,执行router.routes()，返回的是一个dispatch(ctx, next)方法1234567891011121314151617181920212223242526272829303132333435363738394041424344Router.prototype.routes = Router.prototype.middleware = function () &#123; var router = this; var dispatch = function dispatch(ctx, next) &#123; debug(&apos;%s %s&apos;, ctx.method, ctx.path); // 获取path var path = router.opts.routerPath || ctx.routerPath || ctx.path; // 发起path match，获取matched对象 var matched = router.match(path, ctx.method); var layerChain, layer, i; if (ctx.matched) &#123; ctx.matched.push.apply(ctx.matched, matched.path); &#125; else &#123; ctx.matched = matched.path; &#125; // 可以从ctx 取router ctx.router = router; // 判断是否匹配成功 if (!matched.route) return next(); var matchedLayers = matched.pathAndMethod var mostSpecificLayer = matchedLayers[matchedLayers.length - 1] ctx._matchedRoute = mostSpecificLayer.path; if (mostSpecificLayer.name) &#123; ctx._matchedRouteName = mostSpecificLayer.name; &#125; layerChain = matchedLayers.reduce(function(memo, layer) &#123; memo.push(function(ctx, next) &#123; ctx.captures = layer.captures(path, ctx.captures); ctx.params = layer.params(path, ctx.captures, ctx.params); return next(); &#125;); return memo.concat(layer.stack); &#125;, []); return compose(layerChain)(ctx, next); &#125;; dispatch.router = this; return dispatch;&#125;; Router.allowedMethods()执行router.allowedMethods()，返回allowedMethods(ctx, next)方法，判断请求的method是否被允许1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Router.prototype.allowedMethods = function (options) &#123; options = options || &#123;&#125;; var implemented = this.methods; return function allowedMethods(ctx, next) &#123; return next().then(function() &#123; var allowed = &#123;&#125;; if (!ctx.status || ctx.status === 404) &#123; ctx.matched.forEach(function (route) &#123; route.methods.forEach(function (method) &#123; allowed[method] = method; &#125;); &#125;); var allowedArr = Object.keys(allowed); // 判断请求method是否在允许范围内 if (!~implemented.indexOf(ctx.method)) &#123; if (options.throw) &#123; var notImplementedThrowable; if (typeof options.notImplemented === &apos;function&apos;) &#123; notImplementedThrowable = options.notImplemented(); // set whatever the user returns from their function &#125; else &#123; notImplementedThrowable = new HttpError.NotImplemented(); &#125; throw notImplementedThrowable; &#125; else &#123; ctx.status = 501; ctx.set(&apos;Allow&apos;, allowedArr); &#125; &#125; else if (allowedArr.length) &#123; if (ctx.method === &apos;OPTIONS&apos;) &#123; ctx.status = 204; ctx.set(&apos;Allow&apos;, allowedArr); &#125; else if (!allowed[ctx.method]) &#123; if (options.throw) &#123; var notAllowedThrowable; if (typeof options.methodNotAllowed === &apos;function&apos;) &#123; notAllowedThrowable = options.methodNotAllowed(); // set whatever the user returns from their function &#125; else &#123; notAllowedThrowable = new HttpError.MethodNotAllowed(); &#125; throw notAllowedThrowable; &#125; else &#123; ctx.status = 405; ctx.set(&apos;Allow&apos;, allowedArr); &#125; &#125; &#125; &#125; &#125;); &#125;;&#125;; app.use(router.routes()).use(router.allowedMethods());12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182Router.prototype.use = function () &#123; var router = this; // 将传入参数转换为数组 var middleware = Array.prototype.slice.call(arguments); var path = &apos;(.*)&apos;; // support array of paths if (Array.isArray(middleware[0]) &amp;&amp; typeof middleware[0][0] === &apos;string&apos;) &#123; middleware[0].forEach(function (p) &#123; router.use.apply(router, [p].concat(middleware.slice(1))); &#125;); return this; &#125; var hasPath = typeof middleware[0] === &apos;string&apos;; if (hasPath) &#123; path = middleware.shift(); &#125; middleware.forEach(function (m) &#123; if (m.router) &#123; // 对router.routes()参数的处理 m.router.stack.forEach(function (nestedLayer) &#123; if (path) nestedLayer.setPrefix(path); // 绑定layer if (router.opts.prefix) nestedLayer.setPrefix(router.opts.prefix); router.stack.push(nestedLayer); &#125;); if (router.params) &#123; Object.keys(router.params).forEach(function (key) &#123; m.router.param(key, router.params[key]); &#125;); &#125; &#125; else &#123; // 创建并注册一个route router.register(path, [], m, &#123; end: false, ignoreCaptures: !hasPath &#125;); &#125; &#125;); return this;&#125;;// 创建并注册一个routeRouter.prototype.register = function (path, methods, middleware, opts) &#123; opts = opts || &#123;&#125;; var router = this; var stack = this.stack; // support array of paths if (Array.isArray(path)) &#123; path.forEach(function (p) &#123; router.register.call(router, p, methods, middleware, opts); &#125;); return this; &#125; // create route Layer var route = new Layer(path, methods, middleware, &#123; end: opts.end === false ? opts.end : true, name: opts.name, sensitive: opts.sensitive || this.opts.sensitive || false, strict: opts.strict || this.opts.strict || false, prefix: opts.prefix || this.opts.prefix || &quot;&quot;, ignoreCaptures: opts.ignoreCaptures &#125;); if (this.opts.prefix) &#123; route.setPrefix(this.opts.prefix); &#125; // add parameter middleware Object.keys(this.params).forEach(function (param) &#123; route.param(param, this.params[param]); &#125;, this); stack.push(route); return route;&#125;;","tags":[{"name":"koa-router","slug":"koa-router","permalink":"https://facejiong.github.io/tags/koa-router/"}]},{"title":"koa源码分析","date":"2017-05-25T07:29:49.000Z","path":"2017/05/25/koa源码分析/","text":"本文koa版本是2.2.0 创建koa服务: 创建koa的app对象 为app添加中间件 监听端口，创建server 下面是一个简单的示例：123456789101112131415161718192021222324252627282930313233const Koa = require(&apos;koa&apos;);const app = new Koa();// x-response-timeapp.use(async function (ctx, next) &#123; console.log(&apos;x-response-time start&apos;) const start = new Date(); await next(); const ms = new Date() - start; ctx.set(&apos;X-Response-Time&apos;, `$&#123;ms&#125;ms`); console.log(&apos;x-response-time end&apos;)&#125;);// loggerapp.use(async function (ctx, next) &#123; console.log(&apos;logger start&apos;) const start = new Date(); await next(); const ms = new Date() - start; console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;ms&#125;`); console.log(&apos;logger end&apos;)&#125;);// responseapp.use(ctx =&gt; &#123; console.log(&apos;hello world&apos;) ctx.body = &apos;Hello World&apos;;&#125;);app.listen(3000); 当请求http://localhost:3000/时，页面返回&#39;Hello World’ 中间件执行顺序命令行里面顺序打印日志：’x-response-time start’ –&gt; ‘logger start’ –&gt; ‘hello world’ –&gt; ‘logger end’ –&gt; ‘x-response-time end’ async异步函数从请求到响应类似下图 分析代码app对象结构创建Koa的app对象，Application继承Emitter对象，代码结构如下1234567891011121314151617class Application extends Emitter &#123; constructor() &#123; super(); this.proxy = false; // 用于存储中间件的数组 this.middleware = []; this.subdomainOffset = 2; this.env = process.env.NODE_ENV || &apos;development&apos;; // 上下文对象 this.context = Object.create(context); // 请求对象 this.request = Object.create(request); // 响应对象 this.response = Object.create(response); &#125;&#125; 添加中间件koa的中间件是很重要，使用app.use()添加中间件1234567891011121314use(fn) &#123; //判断fn不是函数返回错误 if (typeof fn !== &apos;function&apos;) throw new TypeError(&apos;middleware must be a function!&apos;); if (isGeneratorFunction(fn)) &#123; deprecate(&apos;Support for generators will be removed in v3. &apos; + &apos;See the documentation for examples of how to convert old middleware &apos; + &apos;https://github.com/koajs/koa/blob/master/docs/migration.md&apos;); fn = convert(fn); &#125; debug(&apos;use %s&apos;, fn._name || fn.name || &apos;-&apos;); //把中间件函数push进application的middleware数组内 this.middleware.push(fn); return this;&#125; 创建http服务app.listen()监听端口，listen是createServer()的封装12345listen() &#123; debug(&apos;listen&apos;); const server = http.createServer(this.callback()); return server.listen.apply(server, arguments);&#125; 接收到请求时的回调函数当服务接收到http请求时，触发callback函数，123456789101112131415161718callback() &#123; // 执行中间件 const fn = compose(this.middleware); if (!this.listeners(&apos;error&apos;).length) this.on(&apos;error&apos;, this.onerror); const handleRequest = (req, res) =&gt; &#123; res.statusCode = 404; const ctx = this.createContext(req, res); const onerror = err =&gt; ctx.onerror(err); const handleResponse = () =&gt; respond(ctx); onFinished(res, onerror); // fn() return fn(ctx).then(handleResponse).catch(onerror); &#125;; return handleRequest;&#125; 中间件 compose返回一个用于执行中间件的函数，在callback()函数执行fn(ctx)，从dispatch(0)开始，执行第一个中间件函数，然后递归执行dispatch(i)，执行中间件函数，直到执行完所有中间件函数123456789101112131415161718192021222324252627282930313233function compose (middleware) &#123; // 参数判断 if (!Array.isArray(middleware)) throw new TypeError(&apos;Middleware stack must be an array!&apos;) for (const fn of middleware) &#123; if (typeof fn !== &apos;function&apos;) throw new TypeError(&apos;Middleware must be composed of functions!&apos;) &#125; return function (context, next) &#123; // last called middleware # // 闭包，存储index变量，中间件执行当前坐标 let index = -1 // 从第一个中间件开始执行 return dispatch(0) function dispatch (i) &#123; if (i &lt;= index) return Promise.reject(new Error(&apos;next() called multiple times&apos;)) index = i // 取出中间件函数 let fn = middleware[i] // 最后一个是请求处理 if (i === middleware.length) fn = next if (!fn) return Promise.resolve() try &#123; // 执行中间件函数 return Promise.resolve(fn(context, function next () &#123; // 执行下一个中间件 return dispatch(i + 1) &#125;)) &#125; catch (err) &#123; return Promise.reject(err) &#125; &#125; &#125;&#125; context保存请求，响应对象 context上下文用于管理请求，响应123456789101112131415161718192021createContext(req, res) &#123; const context = Object.create(this.context); const request = context.request = Object.create(this.request); const response = context.response = Object.create(this.response); // 通过context可以获取app,request,response对象 context.app = request.app = response.app = this; context.req = request.req = response.req = req; context.res = request.res = response.res = res; request.ctx = response.ctx = context; request.response = response; response.request = request; context.originalUrl = request.originalUrl = req.url; context.cookies = new Cookies(req, res, &#123; keys: this.keys, secure: request.secure &#125;); request.ip = request.ips[0] || req.socket.remoteAddress || &apos;&apos;; context.accept = request.accept = accepts(req); context.state = &#123;&#125;; return context;&#125; 请求和响应委托(Delegator)给context12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// context 对象const delegate = require(&apos;delegates&apos;);const proto = module.exports = &#123; // 请求委托 delegate(proto, &apos;response&apos;) .method(&apos;set&apos;) .access(&apos;body&apos;) .getter(&apos;headerSent&apos;) // 响应委托 delegate(proto, &apos;request&apos;) .method(&apos;get&apos;) .access(&apos;url&apos;) .getter(&apos;origin&apos;)&#125;// delegate 实现// proto 被委托的对象function Delegator(proto, target) &#123; if (!(this instanceof Delegator)) return new Delegator(proto, target); this.proto = proto; this.target = target; this.methods = []; this.getters = []; this.setters = []; this.fluents = [];&#125;// 获取委托对象Delegator.prototype.access = function(name)&#123; return this.getter(name).setter(name);&#125;;Delegator.prototype.getter = function(name)&#123; var proto = this.proto; var target = this.target; this.getters.push(name); proto.__defineGetter__(name, function()&#123; return this[target][name]; &#125;); // 用于链式调用 return this;&#125;;Delegator.prototype.method = function(name)&#123; var proto = this.proto; var target = this.target; this.methods.push(name); proto[name] = function()&#123; // 方法委托 return this[target][name].apply(this[target], arguments); &#125;; return this;&#125;; response body 处理分三种情况string,buffer,stream123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&#123; get body() &#123; return this._body; &#125;, set body(val) &#123; const original = this._body; this._body = val; if (this.res.headersSent) return; // no content if (null == val) &#123; if (!statuses.empty[this.status]) this.status = 204; this.remove(&apos;Content-Type&apos;); this.remove(&apos;Content-Length&apos;); this.remove(&apos;Transfer-Encoding&apos;); return; &#125; // set the status if (!this._explicitStatus) this.status = 200; // set the content-type only if not yet set const setType = !this.header[&apos;content-type&apos;]; // string字符串处理 if (&apos;string&apos; == typeof val) &#123; if (setType) this.type = /^\\s*&lt;/.test(val) ? &apos;html&apos; : &apos;text&apos;; this.length = Buffer.byteLength(val); return; &#125; // buffer if (Buffer.isBuffer(val)) &#123; if (setType) this.type = &apos;bin&apos;; this.length = val.length; return; &#125; // stream流 if (&apos;function&apos; == typeof val.pipe) &#123; onFinish(this.res, destroy.bind(null, val)); ensureErrorHandler(val, err =&gt; this.ctx.onerror(err)); // overwriting if (null != original &amp;&amp; original != val) this.remove(&apos;Content-Length&apos;); if (setType) this.type = &apos;bin&apos;; return; &#125; // json this.remove(&apos;Content-Length&apos;); this.type = &apos;json&apos;; &#125;,&#125;","tags":[{"name":"koa","slug":"koa","permalink":"https://facejiong.github.io/tags/koa/"}]}]